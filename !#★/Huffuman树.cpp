// Huffuman树
// AC
/*
问题描述
Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。

给出一列数{pi}={p0, p1, …, pn-1}，用这列数构造Huffman树的过程如下：
1.	找到{pi}中最小的两个数，设为pa和pb，将pa和pb从{pi}中删除掉，然后将它们的和加入到{pi}中。这个过程的费用记为pa + pb。
2.	重复步骤1，直到{pi}中只剩下一个数。
在上面的操作过程中，把所有的费用相加，就得到了构造 Huffman 树的总费用。

本题任务：对于给定的一个数列，现在请你求出用该数列构造Huffman树的总费用。

例如，对于数列{pi}={5, 3, 8, 2, 9}，Huffman 树的构造过程如下：
1.	找到{5, 3, 8, 2, 9}中最小的两个数，分别是 2 和 3，从{pi}中删除它们并将和 5 加入，得到{5, 8, 9, 5}，费用为 5。
2.	找到{5, 8, 9, 5}中最小的两个数，分别是 5 和 5，从{pi}中删除它们并将和 10 加入， 得到{8, 9, 10}，费用为 10。
3.	找到{8, 9, 10}中最小的两个数，分别是 8 和 9，从{pi}中删除它们并将和 17 加入， 得到{10, 17}，费用为 17。
4.	找到{10, 17}中最小的两个数，分别是 10 和 17，从{pi}中删除它们并将和 27 加入，得到{27}，费用为 27。
5.	现在，数列中只剩下一个数 27，构造过程结束，总费用为 5+10+17+27=59。

输入格式
输入的第一行包含一个正整数n（n<=100）。
接下来是n个正整数，表示p0, p1, …, pn-1，每个数不超过1000。

输出格式
输出用这些数构造Huffman树的总费用。

样例输入
5
5 3 8 2 9
样例输出
59
*/
#include <stdio.h>
int main()
{
    int n;
    scanf("%d", &n);
    int cost = 0;
    int a[100];

    for (int i = 0; i < n; i++)
        scanf("%d", &a[i]);

    for (int i = n; i > 1; i--) // 当i等于1，也就是说数列中只剩1个数时，退出循环
    {
        int m = 0, n = 1; // m、n指针指向当前数列中最小的两个数
        if (a[0] < a[1])
        {
            m = 1; // m指针指向当前数列中次小的数
            n = 0; // n指针指向当前数列中最小的数
        }
        int j = 2;
        for (; j < i; j++)
        {
            if (a[j] <= a[m])
            {
                if (a[j] < a[n])
                {
                    m = n;
                    n = j;
                }
                else
                {
                    m = j;
                }
            }
        }
        cost = cost + a[n] + a[m];
        a[n] += a[m];               // 将第m个数加到第n个数
        for (j = m; j < i - 1; j++) // 将第m个数从数列中删除
        {
            a[j] = a[j + 1];
        }
    }

    printf("%d\n", cost);

    return 0;
}
