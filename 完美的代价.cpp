// 完美的代价
/*
问题描述
回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。
交换的定义是：交换两个相邻的字符
例如mamad
第一次交换 ad : mamda
第二次交换 md : madma
第三次交换 ma : madam (回文！完美！)

输入格式
第一行是一个整数 N，表示接下来的字符串的长度(N <= 8000)
第二行是一个字符串，长度为N.只包含小写字母输出格式

如果可能，输出最少的交换次数。否则输出Impossible

样例输入
5
mamad 

样例输出
3
*/
// impossible的情况：
// 不管n是奇数还是偶数，只要出现奇数次的字符个数大于等于2，那么就不可能构成回文
// 如果n是偶数，且出现奇数次的字符个数 等于1，那么不可能构成回文
// 如果n是奇数，且出现奇数次的字符个数 等于0，那么不可能构成回文。但这种情况是不可能出现的，只要n是奇数，那么str中一定存在“出现奇数次的字符”

#include <iostream>
using namespace std;
int main()
{
    int n;
    cin >> n;
    string str;
    cin >> str;
    int j = n - 1;             // 此时j下标指向str的最后一个字符
    int cnt = 0;               // cnt：交换的次数
    bool hasOddLetter = false; // hasOddLetter：是否存在 出现奇数次的字符
    for (int i = 0; i < j; i++)
    {
        for (int k = j; k >= i; k--) // k下标从倒数第二个字符起，一路往前到i，目的是寻找和str[i]相同的str[k]
        {
            if (k == i) //如果找不到和str[i]相同的字符
            {
                if (n % 2 == 0 || hasOddLetter == true)
                {
                    cout << "Impossible";
                    return 0;
                }
                hasOddLetter = true;
                // 如果n是奇数，计算最终的回文中那个中间字符被交换了多少次的时候，不必真的把这个字符移动到中间位置
                // 因为如果你真的将这个字符移动到了中间位置，假设有一对字符都在中间位置的左边或右边，
                // 那么交换成回文的时候其中一个字符就要经过中间，这样每处理一对字符，cnt就会被多加一个1，而这个1是没有必要的，因为你完全可以等除了这个中间字符以外的所有字符移动完了之后再把这个中间字符移动过去，只有这样的交换策略才能保证交换次数最少。
                cnt += (n / 2 - i);
            }
            else if (str[k] == str[i]) //如果找到了和str[i]相同的字符：str[k]
            {
                for (int l = k; l < j; l++) //把str[k]交换到str[j]处
                {
                    swap(str[l], str[l + 1]);
                    cnt++; // 交换次数加1
                }
                j--;
                break; // 跳出第二层for循环
            }
        } // 第二层for循环
    }     // 第一层for循环
    cout << cnt;
    return 0;
}
