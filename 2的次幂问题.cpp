// 2的次幂问题
/*
问题描述
任何一个正整数都可以用2进制表示，例如：137的2进制表示为10001001。
将这种2进制表示写成2的次幂的和的形式，令次幂高的排在前面，可得到如下表达式：137=2^7+2^3+2^0
现在约定幂次用括号来表示，即a^b表示为a(b) 此时，137可表示为：2(7)+2(3)+2(0)
进一步：
7=2^2+2+2^0 (2^1 用 2 表示)
3=2+2^0
所以最后137可表示为：2(2(2)+2+2(0))+2(2+2(0))+2(0) 

又如：1315=2^10+2^8+2^5+2+1
所以1315最后可表示为 ： 
2(2(2+2(0))+2)+
2(2(2+2(0)))+
2(2(2)+2(0))+
2+
2(0)

输入格式
正整数(1<=n<=20000)
输出格式
符合约定的n的0，2表示(在表示中不能有空格) ——也就是说只能出现 2的0次方 和 2的2次方

样例输入
137
样例输出
2(2(2)+2+2(0))+2(2+2(0))+2(0)

样例输入
1315
样例输出
2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)

提示
用递归实现会比较简单，可以一边递归一边输出
*/

#include <stdio.h>
#include <math.h>
void fun(int x)
{
    int y = (int)(log(x) / log(2));
    int remainingPart = x - pow(2, y);
    if (y == 0) // 如果y==0，则说明x为1（输入为正整数，remainingPart是两个整数之差，所以x只可能是整数），进而remainingPart为0,也就是说不再有剩余的部分需要用2的次幂来表示，所以输出“2(0)”后就可以退出fun函数了
    {
        printf("2(0)");
        return;
    }
    else if (y == 1)
    {
        printf("2");
    }
    else
    {
        printf("2(");
        fun(y);
        printf(")");
    }
    if (remainingPart)
    {
        printf("+");
        fun(remainingPart);
    }
}
int main()
{
    int n;
    scanf("%d", &n);
    fun(n);
    return 0;
}
