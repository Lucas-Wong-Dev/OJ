// 最大最小公倍数（贪心算法）
/*
问题描述
已知一个正整数N，问从1~N中任选出三个数，他们的最小公倍数最大可以为多少。

输入格式
输入一个正整数N。

输出格式
输出一个整数，表示你找到的最小公倍数。 

样例输入
9

样例输出
504

数据规模与约定
1 <= N <= 10^6。
*/
// 分析:
// 1.如果N<=2, 那么最小公倍数的最大值为N
// 2.如果N是奇数，那么最小公倍数的最大值为末尾的三个数相乘
// 3.如果N是偶数，那么末尾的三个数中会有两个偶数，那么末尾的三个数乘积肯定无法作为最小公倍数了，因为这个乘积除2后仍然可以作为这末尾的三个数的公倍数
// 此时分两种情况：
// (1)如果N是偶数且不是3的倍数， 比如8，那么跳过N-2这个数而选择8 7 5三个数相乘并把乘积作为最小公倍数的最大值，即：此时最小公倍数的最大值为N * (N – 1) * (N – 3)
// (2)如果N是偶数且是3的倍数，比如6，如果还像上面那样算最大值的话会得到6*5*3==90。因为6和3相差3，所以这个乘积除3后（等于30）仍然可以作为这三个数的公倍数，也就是说这个乘积并不是这三个数的最小公倍数。即：此时最小公倍数的最大值为(N – 1) * (N – 2) * (N – 3)
#include <iostream>
using namespace std;
int main()
{
    long long N, ans;
    cin >> N;
    if (N <= 2)
        ans = N;
    else if (N % 2 == 1)
        ans = N * (N - 1) * (N - 2);
    else if (N % 3 == 0)
        ans = (N - 1) * (N - 2) * (N - 3);
    else
        ans = N * (N - 1) * (N - 3);
    cout << ans;
    return 0;
}